<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>notcord</title>
  <style>
    :root {
      --theme-1: #1B2B3A;
      --theme-2: #0F1A25;
      --theme-3: #2B3A4A;
      --muted: #C5D3E0;
      --accent: #3F72AF; /* A more neutral, modern accent */
      --me-bg: #2b3440; /* Kept this for 'me' messages if needed, though not directly used in bubbles */
      --border: rgba(255, 255, 255, 0.08);
      --text: #F5F5F5;
      --yellow: #f7b500; /* Kept as it might be used */
      --pin-bg: rgba(63, 114, 175, 0.1); /* Based on new accent */
      --pin-accent: rgba(63, 114, 175, 0.25); /* Based on new accent */
    }

    /* Base styles */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Helvetica,Arial;color:var(--text);
      background:linear-gradient(180deg,var(--theme-1) 0%, var(--theme-2) 100%);
      -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;
    }
    .hidden { display: none !important; }

    /* Layout */
    .app { width:100%; height:100vh; display:grid; grid-template-columns:260px 1fr 260px; overflow:hidden; gap:10px; padding:10px; position:relative; }

    /* Sidebar and Player Panel general styles */
    .sidebar, .playersPanel {
      padding:14px; display:flex; flex-direction:column; gap:12px; height:100vh; overflow-y:auto;
      background:linear-gradient(180deg,var(--theme-1),var(--theme-2));
      border-radius:12px;
    }
    .sidebar{ border-right:1px solid var(--border); }
    .playersPanel{ border-left:1px solid var(--border); }

    /* Brand */
    .brand{display:flex;gap:10px;align-items:center;font-weight:700;font-size:18px}
    .brand .dot{width:28px;height:28px;border-radius:8px;background:var(--accent);box-shadow:0 8px 26px rgba(63, 114, 175, 0.45);display:flex;align-items:center;justify-content:center;font-weight:800;color:white}
    .brand .name{color:var(--accent);font-weight:800;font-size:18px}

    /* Username sections */
    .usernameBox{display:flex;gap:8px;align-items:center}
    .usernameBox input{flex:1;padding:10px 12px;background:transparent;border:1px solid var(--border);border-radius:10px;color:inherit;outline:none}
    .usernameBox button{padding:8px 10px;border-radius:10px;border:1px solid var(--border);background:linear-gradient(90deg,var(--accent),var(--accent));color:white;cursor:pointer}
    .usernameLocked{display:flex;gap:8px;align-items:center;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid var(--border);font-weight:600;overflow:hidden}
    
    /* Avatar styles */
    .avatar-placeholder {
      width:36px;height:36px;border-radius:50%;overflow:hidden;background:rgba(255,255,255,0.03);
      display:flex;align-items:center;justify-content:center;
      flex-shrink:0; /* Prevents shrinking in flex containers */
    }
    .avatar-placeholder img { width:100%; height:100%; object-fit:cover; }
    
    .usernameLocked .avatar-placeholder { width:36px; height:36px; } /* Specific for locked username display */
    .message .avatar-placeholder { width:36px; height:36px; } /* Specific for message avatars */
    .player .avatar-placeholder { width:20px; height:20px; margin-left:8px; } /* Specific for player list avatars */

    /* Channels */
    .channels{margin-top:6px;display:flex;flex-direction:column;gap:6px}
    .channel{padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer;border:1px solid transparent;display:flex;justify-content:space-between;align-items:center}
    .channel:hover{background:rgba(255,255,255,0.01)}
    .channel.active{background:linear-gradient(90deg, rgba(63, 114, 175, 0.12), rgba(63, 114, 175, 0.02));color:var(--text);border-color:var(--accent)}

    /* Settings */
    .settings{margin-top:auto;display:flex;flex-direction:column;gap:8px;padding-top:8px;border-top:1px solid var(--border)}
    .settings label{font-size:13px;color:var(--muted);display:flex;flex-direction:column;gap:6px}
    .settings input[type="color"]{width:48px;height:32px;padding:0;border:none;background:transparent;cursor:pointer}
    .settings .toggleBtn{padding:8px;border-radius:8px;background:transparent;border:1px solid var(--border);color:var(--muted);cursor:pointer}

    /* CHAT Panel */
    .chatPanel{display:flex;flex-direction:column;min-height:0;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:12px;padding:10px;position:relative}
    .chatBox{display:flex;flex-direction:column;height:100%;min-height:0}

    /* Chat Header */
    .header{padding:12px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px;background:transparent}
    .header h2{margin:0;font-size:18px}
    .header .spacer{flex:1}
    .status{color:var(--muted);font-size:13px}
    .typing{color:var(--muted);font-size:12px;height:18px}

    /* Messages container */
    .messages{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px;scroll-behavior:smooth;min-height:0;background:transparent}

    /* Pinned message */
    .pinnedCenter{ position:absolute; left:50%; transform:translateX(-50%); top:10px; z-index:30; background:var(--pin-bg); border:1px solid var(--pin-accent); padding:10px 14px; border-radius:12px; color:var(--text); display:flex; gap:10px; align-items:center; justify-content:center; max-width:70%; text-align:center; box-shadow:0 10px 30px rgba(2,6,23,0.6); transition:opacity .2s ease, transform .15s ease; }
    .pinnedCenter .pin-close{ background: transparent; border: none; color: var(--muted); cursor: pointer; margin-left: 8px; font-weight: 700; }
    .pinnedCenter .pinTitle{font-weight:800;color:var(--accent); margin-right:8px}

    /* Individual message */
    .message{display:flex;gap:12px;align-items:flex-start;max-width:85%}
    .message.me{margin-left:auto;justify-content:flex-end}
    .bubble{
      background:var(--theme-3);
      color:var(--text);
      padding:10px 12px;border-radius:12px;display:flex;flex-direction:column;gap:8px;word-break:break-word;
      border:1px solid var(--accent); /* border related to theme accent color */
      box-shadow:0 8px 28px rgba(2,6,23,0.6);
      max-width:560px;
      position:relative;
      cursor:default;
    }
    .bubble .actions{position:absolute;right:8px;top:6px;display:flex;gap:6px}
    .bubble .actions button{background:transparent;border:none;color:var(--muted);cursor:pointer;padding:4px;border-radius:6px}
    .meta{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
    .meta .name{font-weight:700}
    .meta .time{font-size:12px;color:var(--muted)}
    .text{white-space:pre-wrap;color:inherit;font-size:15px;word-break:break-word;overflow-wrap:break-word}
    .photoMessage img { max-width: 100%; height:auto; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); cursor:pointer; transition:transform .12s; display:block }
    .photoMessage img:hover{ transform: scale(1.02) }

    /* Input Area */
    .inputArea, .photoUploadArea, .codeUploadArea {
      padding:12px;border-top:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    }
    .inputArea { display:flex;gap:8px;align-items:flex-end; }
    .inputArea textarea, .codeUploadArea textarea, .codeUploadArea input[type="text"] {
      flex:1;min-height:44px;max-height:160px;resize:none;padding:10px;border-radius:10px;background:transparent;border:1px solid var(--border);color:inherit;outline:none;
    }
    .inputArea textarea { font-family:Inter,system-ui,Roboto,Helvetica,Arial; } /* Ensure text area matches app font */
    .codeUploadArea textarea, .codeUploadArea input[type="text"] { font-family:'Courier New', monospace; }

    .controls{display:flex;flex-direction:column;align-items:flex-end;gap:6px;min-width:120px}
    .charCount{font-size:12px;color:var(--muted)}
    .sendBtn{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .sendBtn:disabled{opacity:0.6;cursor:default}

    .photoUploadArea { display:flex; gap:8px; align-items:center; }
    .photoUploadArea input[type=file]{ flex:1 }
    .photoUploadArea button{ background:var(--accent); color:white; border:none; padding:8px 12px; border-radius:10px; cursor:pointer }
    
    .codeUploadArea { display:block; }
    .codeUploadArea .code-controls { display:flex;gap:8px;align-items:center;margin-top:8px }
    .codeUploadArea .upload-btn { background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:10px;cursor:pointer }

    /* Players Panel */
    .playersPanel h3{margin:0;font-size:15px;color:var(--muted)}
    .playersList{display:flex;flex-direction:column;gap:6px;overflow:auto}
    .player{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid transparent;color:var(--text)}
    .player.offline{opacity:0.6}
    .player .statusDot{width:10px;height:10px;border-radius:50%;margin-right:8px;flex-shrink:0;border:2px solid rgba(0,0,0,0.12)}
    .player.online .statusDot{background:#4CAF50;box-shadow:0 0 8px rgba(76,175,80,0.12)} /* Generic green for online */
    .player.offline .statusDot{background:#a0a0a0}
    .player .playerName{font-weight:600}

    /* Presets */
    .presetsArea{border-top:1px dashed rgba(255,255,255,0.03);padding-top:10px;margin-top:8px}
    .preset-slot{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid var(--border)}

    /* Mentions and Replies */
    .mention { background: rgba(63, 114, 175, 0.06); padding:2px 6px; border-radius:6px; font-weight:700; color:var(--accent); }
    .replyQuote { background: rgba(255,255,255,0.03); border-left: 3px solid var(--accent); padding: 6px 10px; margin-bottom: 6px; border-radius: 4px; font-size: 13px; color: var(--muted); font-style: italic; }
    
    /* Code message styles */
    .code-block {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px;
      padding-top: 36px;
      margin: 8px 0;
      position: relative;
      border: 1px solid rgba(255,255,255,0.1);
      font-family: 'Courier New', monospace;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 400px;
      overflow-y: auto;
    }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: var(--accent); /* Use generic accent for copy btn */
      border: none;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }
    .copy-btn:hover { background: #30609a; } /* Darken accent on hover */
    .copy-btn.copied { background: #4CAF50; color: #fff; } /* Green for copied */
    .language-tag {
      position: absolute;
      top: 8px;
      left: 8px;
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
    }
    
    /* Responsive adjustments */
    @media (max-width:980px){ .app{grid-template-columns:200px 1fr 140px} }
    @media (max-width:720px){ .app{grid-template-columns:1fr} .sidebar,.playersPanel{display:none} }
  </style>
</head>
<body>
  <div class="app" id="app">
    
    <aside class="sidebar" id="sidebar">
      <div class="brand"><div class="dot" aria-hidden>ðŸ’¬</div><div class="name">notcord</div></div>

      <div id="usernameSection">
        <div class="usernameBox" id="usernameBox">
          <input type="text" id="usernameInput" placeholder="Choose username (max 8 chars)" maxlength="8" />
          <input type="file" id="avatarInput" accept="image/*" title="Upload avatar (weekly)"/>
          <button id="setNameBtn">Set</button>
        </div>
        <div class="usernameLocked hidden" id="usernameLocked">
          <div class="avatar-placeholder" id="avatarDisplay"></div>
          <div style="display:flex;flex-direction:column;gap:4px">
            <div id="usernameDisplay"></div>
            <div style="font-size:12px;color:var(--muted)" id="nameMeta"></div>
          </div>
          <div style="margin-left:auto;display:flex;flex-direction:column;gap:6px">
            <button id="changeNameBtn" class="toggleBtn">Change</button>
            <button id="changeAvatarBtn" class="toggleBtn">Avatar</button>
          </div>
        </div>
      </div>

      <div class="channels" id="channels">
        <div class="channel active" data-id="general" role="button"># general</div>
        <div class="channel" data-id="photos" role="button"># photos</div>
        <div class="channel" data-id="code" role="button"># code {}</div>
      </div>

      <div class="settings" aria-label="Appearance settings">
        <label>Your name color
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="nameColor" title="Name color" />
            <div style="flex:1"></div>
            <button id="resetNameColor" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme Color 1
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor1" title="Theme color 1" />
            <div style="flex:1"></div>
            <button id="resetTheme1" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme Color 2
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor2" title="Theme color 2" />
            <div style="flex:1"></div>
            <button id="resetTheme2" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Theme Color 3
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="themeColor3" title="Theme color 3" />
            <div style="flex:1"></div>
            <button id="resetTheme3" class="toggleBtn">Reset</button>
          </div>
        </label>

        <label>Accent Color
          <div style="display:flex;gap:8px;align-items:center">
            <input type="color" id="accentColor" title="Accent color" />
            <div style="flex:1"></div>
            <button id="resetAccent" class="toggleBtn">Reset</button>
          </div>
        </label>

        <div style="font-size:12px;color:var(--muted);padding-top:6px">
          Username/Avatar change limited to once per 7 days. Use "@name" to ping. Pinned message shown top center for everyone.
        </div>
      </div>
    </aside>

    <section class="chatPanel">
      <div class="chatBox" id="chatBox">
        <div class="header">
          <h2 id="channelTitle"># general</h2>
          <div class="spacer"></div>
          <div class="right">
            <div id="status" class="status">Connecting...</div>
            <div id="typingIndicator" class="typing"></div>
          </div>
        </div>

        <div id="pinnedCenter" class="pinnedCenter hidden"></div>

        <div class="messages" id="messages" role="log" aria-atomic="false"></div>

        <div class="inputArea" id="inputWrapper">
          <textarea id="messageInput" placeholder="Message (Shift+Enter for newline)" maxlength="2000"></textarea>
          <div class="controls">
            <div class="charCount" id="charCount">0 / 256</div>
            <button id="sendBtn" class="sendBtn" disabled>Send</button>
          </div>
        </div>

        <div class="photoUploadArea hidden" id="photoUploadWrapper">
          <input type="file" id="photoInput" accept="image/*,image/gif" />
          <button id="uploadPhotoBtn" disabled>Upload Photo/GIF</button>
        </div>
        
        <div class="codeUploadArea hidden" id="codeUploadWrapper">
          <textarea id="codeInput" placeholder="Paste your code here (no limits!)"></textarea>
          <div class="code-controls">
            <input type="text" id="languageInput" placeholder="Language (e.g., javascript, python)">
            <button id="uploadCodeBtn" class="upload-btn">Upload Code</button>
          </div>
        </div>
      </div>
    </section>

    <aside class="playersPanel" id="playersPanel">
      <h3>Players</h3>
      <div id="playersStatus" style="font-size:13px;color:var(--muted)">Loading...</div>
      <div style="height:6px"></div>
      <div class="playersList" id="playersList" aria-live="polite"></div>

      <div class="presetsArea" id="presetsArea">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-size:13px;color:var(--muted)">Theme Presets ðŸŽ¨</div>
        </div>
        <div id="presetsList" style="margin-top:8px;display:flex;flex-direction:column;gap:8px">
          <div class="preset-slot" data-slot="1">
            <div style="font-size:12px;font-weight:600;margin-bottom:4px">Slot 1</div>
            <div style="display:flex;gap:4px">
              <button class="toggleBtn preset-load" style="flex:1;font-size:11px">Load</button>
              <button class="toggleBtn preset-save" style="flex:1;font-size:11px">Save</button>
              <button class="toggleBtn preset-reset" style="font-size:11px">Reset</button>
            </div>
          </div>
          <div class="preset-slot" data-slot="2">
            <div style="font-size:12px;font-weight:600;margin-bottom:4px">Slot 2</div>
            <div style="display:flex;gap:4px">
              <button class="toggleBtn preset-load" style="flex:1;font-size:11px">Load</button>
              <button class="toggleBtn preset-save" style="flex:1;font-size:11px">Save</button>
              <button class="toggleBtn preset-reset" style="font-size:11px">Reset</button>
            </div>
          </div>
          <div class="preset-slot" data-slot="3">
            <div style="font-size:12px;font-weight:600;margin-bottom:4px">Slot 3</div>
            <div style="display:flex;gap:4px">
              <button class="toggleBtn preset-load" style="flex:1;font-size:11px">Load</button>
              <button class="toggleBtn preset-save" style="flex:1;font-size:11px">Save</button>
              <button class="toggleBtn preset-reset" style="font-size:11px">Reset</button>
            </div>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <script defer>
    (function(){
      // --- Endpoints ---
      // NOTE: Using mockapi.io is for demonstration/testing. For a production app,
      // you would need stable backend APIs, ideally with WebSockets for real-time chat
      // instead of polling to avoid rate limits and improve performance.
      const CHANNELS = {
        general: 'https://68e839b2f2707e6128ca35e1.mockapi.io/chat',
        photos: 'https://68eeed86b06cc802829ba196.mockapi.io/photos',
        code: 'https://68eeed86b06cc802829ba196.mockapi.io/code'
      };
      const PLAYERS_API = 'https://68e839b2f2707e6128ca35e1.mockapi.io/players';
      const PINS_PUBLIC_API = 'https://6907fcb5b49bea95fbf20cbc.mockapi.io/pined';

      // --- Config ---
      const BAD_WORDS = ['fuck','bitch','nigger','tun tun tun sahur','Ð½Ð°Ñ…ÑƒÐ¹','Ð³ÐµÐ¹','gay','Ñ…ÑƒÐµÑ‚Ð°']; // Consider server-side filtering
      const MAX_MESSAGES_KEEP = 95;
      const TRIM_DELETE_COUNT = 10;
      const MAX_CHARS_MESSAGE = 256;
      const TYPING_KEY = 'notcord_typing_v3';
      const TYPING_EXPIRE_MS = 5000;
      const HEARTBEAT_MS = 5000;
      const WEEK_MS = 7 * 24 * 60 * 60 * 1000;

      // --- UI refs ---
      const appEl = document.getElementById('app');
      const channelsEl = document.getElementById('channels');
      const channelTitleEl = document.getElementById('channelTitle');
      const messagesEl = document.getElementById('messages');
      const statusEl = document.getElementById('status');
      const typingIndicatorEl = document.getElementById('typingIndicator');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const charCountEl = document.getElementById('charCount');
      const inputWrapper = document.getElementById('inputWrapper');
      const photoUploadWrapper = document.getElementById('photoUploadWrapper');
      const photoInput = document.getElementById('photoInput');
      const uploadPhotoBtn = document.getElementById('uploadPhotoBtn');
      const codeUploadWrapper = document.getElementById('codeUploadWrapper');
      const codeInput = document.getElementById('codeInput');
      const languageInput = document.getElementById('languageInput');
      const uploadCodeBtn = document.getElementById('uploadCodeBtn');

      const usernameBox = document.getElementById('usernameBox');
      const usernameInput = document.getElementById('usernameInput');
      const setNameBtn = document.getElementById('setNameBtn');
      const usernameLocked = document.getElementById('usernameLocked');
      const usernameDisplay = document.getElementById('usernameDisplay');
      const avatarInput = document.getElementById('avatarInput');
      const avatarDisplay = document.getElementById('avatarDisplay');
      const changeNameBtn = document.getElementById('changeNameBtn');
      const changeAvatarBtn = document.getElementById('changeAvatarBtn');
      const nameMeta = document.getElementById('nameMeta');

      const nameColorInput = document.getElementById('nameColor');
      const resetNameColorBtn = document.getElementById('resetNameColor');
      const themeColor1Input = document.getElementById('themeColor1');
      const resetTheme1Btn = document.getElementById('resetTheme1');
      const themeColor2Input = document.getElementById('themeColor2');
      const resetTheme2Btn = document.getElementById('resetTheme2');
      const themeColor3Input = document.getElementById('themeColor3');
      const resetTheme3Btn = document.getElementById('resetTheme3');
      const accentColorInput = document.getElementById('accentColor');
      const resetAccentBtn = document.getElementById('resetAccent');

      const playersListEl = document.getElementById('playersList');
      const playersStatusEl = document.getElementById('playersStatus');

      const pinnedCenterEl = document.getElementById('pinnedCenter');

      // --- State ---
      let activeChannel = localStorage.getItem('notcord_channel') || 'general';
      let apiBase = CHANNELS[activeChannel] || null;
      let pollingMessagesInterval = null;
      let pollingPlayersInterval = null;
      let heartbeatInterval = null;
      let isSending = false;

      let username = localStorage.getItem('notcord_username') || '';
      let nameColor = localStorage.getItem('notcord_nameColor') || '#F5F5F5'; // Default to text color
      let themeColor1 = localStorage.getItem('notcord_theme1') || '#1B2B3A';
      let themeColor2 = localStorage.getItem('notcord_theme2') || '#0F1A25';
      let themeColor3 = localStorage.getItem('notcord_theme3') || '#2B3A4A';
      let accentColor = localStorage.getItem('notcord_accent') || '#3F72AF';
      let localPlayerId = localStorage.getItem('notcord_playerId') || null;

      let lastNameChange = Number(localStorage.getItem('notcord_lastNameChange') || 0);
      let lastAvatarChange = Number(localStorage.getItem('notcord_lastAvatarChange') || 0);
      let avatarDataUrl = localStorage.getItem('notcord_avatar') || null;

      const muteMap = new Map();

      // Track notifications already sent
      const notifiedKey = 'notcord_notified_messages';
      let notifiedSet = new Set(JSON.parse(localStorage.getItem(notifiedKey) || '[]'));

      // interval id for pin rotation
      let pinRotationIntervalId = null;
      let publicPinnedList = [];

      // reply state
      let replyToMessage = null;

      // message count state
      let currentMessageCount = 0;
      let firstOpenScrollDone = false; // Flag to ensure initial scroll only happens once

      // --- Helpers ---
      function setStatus(txt){ statusEl.textContent = txt; }
      function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&','<':'<','>':'>','"':'"',"'":'''}[c])); }
      function formatTime(iso){ try{ const d=new Date(iso); if(isNaN(d)) return ''; return d.toLocaleString([], {hour:'2-digit', minute:'2-digit'}); }catch(e){return ''} }
      
      function applyTheme(){ 
        document.documentElement.style.setProperty('--theme-1', themeColor1); 
        document.documentElement.style.setProperty('--theme-2', themeColor2); 
        document.documentElement.style.setProperty('--theme-3', themeColor3); 
        document.documentElement.style.setProperty('--accent', accentColor); 
      }
      function initializeAppearanceInputs(){ 
        nameColorInput.value = nameColor;
        themeColor1Input.value = themeColor1;
        themeColor2Input.value = themeColor2;
        themeColor3Input.value = themeColor3;
        accentColorInput.value = accentColor;
      }

      function readTypingMap(){ try{ return JSON.parse(localStorage.getItem(TYPING_KEY)||'{}'); }catch(e){ return {}; } }
      function writeTypingMap(m){ try{ localStorage.setItem(TYPING_KEY, JSON.stringify(m)); }catch(e){} }
      
      function updateTypingUI(){
        const map = readTypingMap();
        const channelMap = map[activeChannel] || {};
        const now = Date.now();
        const typers = Object.keys(channelMap).filter(u => u !== username && (now - channelMap[u]) <= TYPING_EXPIRE_MS);
        if(!typers.length) typingIndicatorEl.textContent = '';
        else if(typers.length === 1) typingIndicatorEl.textContent = typers[0] + ' is typing...';
        else typingIndicatorEl.textContent = typers[0] + ' and ' + (typers.length-1) + ' others are typing...';
      }
      window.addEventListener('storage', (e)=> { if(e.key === TYPING_KEY) updateTypingUI(); });

      function isUserMuted(user){
        const t = muteMap.get(user);
        if(!t) return false;
        if(Date.now() > t){ muteMap.delete(user); return false; }
        return true;
      }
      function muteUser(user, seconds=120){ muteMap.set(user, Date.now() + seconds*1000); }

      function containsBadWords(text){
        if(!text) return false;
        const lower = text.toLowerCase();
        return BAD_WORDS.some(w => w && lower.includes(w));
      }

      // --- Theme Presets ---
      const DEFAULT_PRESETS = {
        1: { theme1: '#1B2B3A', theme2: '#0F1A25', theme3: '#2B3A4A', accent: '#3F72AF' }, // Default Dark
        2: { theme1: '#2A3C4C', theme2: '#1C2B3A', theme3: '#3C4C5C', accent: '#8E9AAF' }, // Cool Grey
        3: { theme1: '#3A2B3A', theme2: '#251A25', theme3: '#4A3A4A', accent: '#D372AF' }  // Purple Haze
      };

      function getPresets(){
        try{
          const saved = localStorage.getItem('notcord_presets');
          return saved ? JSON.parse(saved) : {...DEFAULT_PRESETS};
        }catch(e){ return {...DEFAULT_PRESETS}; }
      }

      function savePresets(presets){
        try{ localStorage.setItem('notcord_presets', JSON.stringify(presets)); }catch(e){}
      }

      function loadPreset(slot){
        const presets = getPresets();
        const preset = presets[slot];
        if(!preset) return;
        themeColor1 = preset.theme1;
        themeColor2 = preset.theme2;
        themeColor3 = preset.theme3;
        accentColor = preset.accent;
        localStorage.setItem('notcord_theme1', themeColor1);
        localStorage.setItem('notcord_theme2', themeColor2);
        localStorage.setItem('notcord_theme3', themeColor3);
        localStorage.setItem('notcord_accent', accentColor);
        initializeAppearanceInputs();
        applyTheme();
        setStatus(`Preset ${slot} loaded`);
      }

      function saveCurrentToPreset(slot){
        const presets = getPresets();
        presets[slot] = { theme1: themeColor1, theme2: themeColor2, theme3: themeColor3, accent: accentColor };
        savePresets(presets);
        setStatus(`Saved to preset ${slot}`);
      }

      function resetPreset(slot){
        const presets = getPresets();
        presets[slot] = {...DEFAULT_PRESETS[slot]};
        savePresets(presets);
        setStatus(`Preset ${slot} reset to default`);
      }

      function initPresets(){
        document.querySelectorAll('.preset-slot').forEach(slotEl => {
          const slot = parseInt(slotEl.dataset.slot);
          slotEl.querySelector('.preset-load').addEventListener('click', ()=> loadPreset(slot));
          slotEl.querySelector('.preset-save').addEventListener('click', ()=> saveCurrentToPreset(slot));
          slotEl.querySelector('.preset-reset').addEventListener('click', ()=> resetPreset(slot));
        });
      }

      // --- Pinned Messages ---
      async function fetchPublicPinned(){
        try{
          const res = await fetch(PINS_PUBLIC_API);
          if(!res.ok) throw new Error('failed fetching public pins');
          let data = await res.json();
          if(!Array.isArray(data)) data = [];
          publicPinnedList = data.filter(p => p && p.message && p.message.trim());
        }catch(e){ console.error(e); publicPinnedList = []; }
      }

      function startPinRotation(interval_ms=7000){
        if(pinRotationIntervalId) clearInterval(pinRotationIntervalId);
        let idx = 0;
        function rotatePins(){
          if(publicPinnedList.length === 0){ pinnedCenterEl.classList.add('hidden'); return; }
          const p = publicPinnedList[idx % publicPinnedList.length];
          if(p && p.message){
            pinnedCenterEl.innerHTML = `<span class="pinTitle">ðŸ“Œ PIN:</span> <span style="font-weight:600">${escapeHtml(p.message)}</span>`;
            pinnedCenterEl.classList.remove('hidden');
          } else {
            pinnedCenterEl.classList.add('hidden');
          }
          idx = (idx+1) % publicPinnedList.length;
        }
        rotatePins();
        pinRotationIntervalId = setInterval(rotatePins, interval_ms);
      }

      // --- Players ---
      async function safeFetch(url, method='GET', body=null){
        const opts = { method, headers:{'Content-Type':'application/json'} };
        if(body) opts.body = JSON.stringify(body);
        const res = await fetch(url, opts);
        return res;
      }

      async function upsertLocalPlayer(){
        if(!username) return;
        try{
          const payload = { name: username, lastSeen: new Date().toISOString(), online:true, nameColor, avatarUrl: avatarDataUrl };
          if(!localPlayerId){
            const res = await safeFetch(PLAYERS_API, 'POST', payload);
            if(res.ok){
              const data = await res.json();
              localPlayerId = data.id;
              localStorage.setItem('notcord_playerId', localPlayerId);
            }
          } else {
            await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', payload);
          }
        }catch(e){ console.error(e); }
      }

      async function setLocalPlayerOnlineState(onlineState){
        if(!localPlayerId) return;
        try{
          await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { lastSeen: new Date().toISOString(), online:onlineState, name: username, nameColor, avatarUrl: avatarDataUrl });
        }catch(e){ console.error(e); }
      }

      function startHeartbeat(){
        if(heartbeatInterval) clearInterval(heartbeatInterval);
        heartbeatInterval = setInterval(async ()=>{
          if(username && localPlayerId){
            try{
              await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { lastSeen: new Date().toISOString(), online:true, name: username, nameColor, avatarUrl: avatarDataUrl });
            }catch(e){}
          }
        }, HEARTBEAT_MS);
      }

      function stopHeartbeat(){
        if(heartbeatInterval){ clearInterval(heartbeatInterval); heartbeatInterval = null; }
      }

      async function fetchPlayers(){
        try{
          const res = await fetch(PLAYERS_API);
          if(!res.ok) throw new Error('players fetch fail');
          let data = await res.json();
          if(!Array.isArray(data)) data = [];
          const now = Date.now();
          const ONLINE_THRESHOLD_MS = 11000;
          const sorted = data.sort((a,b)=>{
            const aTime = a.lastSeen ? new Date(a.lastSeen).getTime() : 0;
            const bTime = b.lastSeen ? new Date(b.lastSeen).getTime() : 0;
            const aOnline = a.online && (now - aTime < ONLINE_THRESHOLD_MS);
            const bOnline = b.online && (now - bTime < ONLINE_THRESHOLD_MS);
            if(aOnline && !bOnline) return -1;
            if(!aOnline && bOnline) return 1;
            return bTime - aTime;
          });
          const total = sorted.length;
          const onlineCount = sorted.filter(p => {
            const pTime = p.lastSeen ? new Date(p.lastSeen).getTime() : 0;
            return p.online && (now - pTime < ONLINE_THRESHOLD_MS);
          }).length;
          playersStatusEl.textContent = `${onlineCount} online / ${total} total`;
          playersListEl.innerHTML = '';
          for(const p of sorted){
            const pTime = p.lastSeen ? new Date(p.lastSeen).getTime() : 0;
            const isOnline = p.online && (now - pTime < ONLINE_THRESHOLD_MS);
            
            const div = document.createElement('div');
            div.className = `player ${isOnline ? 'online' : 'offline'}`;

            const dotSpan = document.createElement('span');
            dotSpan.className = 'statusDot';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'playerName';
            nameSpan.textContent = p.name || 'Anonymous';
            if(p.nameColor){ nameSpan.style.color = p.nameColor; }
            
            const avatarEl = document.createElement('div');
            avatarEl.className = 'avatar-placeholder';
            renderAvatarToEl(p.avatarUrl, avatarEl);

            div.append(dotSpan, nameSpan, avatarEl);
            playersListEl.appendChild(div);
          }
        }catch(e){ console.error(e); }
      }

      // --- Messages ---
      async function fetchMessages(){
        if(!apiBase) return;
        try{
          const res = await fetch(apiBase);
          if(!res.ok) throw new Error('fetch failed');
          let data = await res.json();
          if(!Array.isArray(data)) data = [];
          const sorted = data.sort((a,b)=> new Date(a.createdAt) - new Date(b.createdAt));
          
          if(sorted.length > MAX_MESSAGES_KEEP){
            const toDelete = sorted.slice(0, TRIM_DELETE_COUNT);
            for(const m of toDelete){
              try{ await fetch(`${apiBase}/${m.id}`, {method:'DELETE'}); }catch(e){}
            }
            await fetchMessages(); // Re-fetch after cleanup
            return;
          }
          currentMessageCount = sorted.length;
          updateStatusWithMessageCount();
          renderMessages(sorted);
        }catch(e){ console.error(e); setStatus('Error loading messages'); }
      }

      function updateStatusWithMessageCount(){
        setStatus(`Connected - ${currentMessageCount} messages`);
      }

      function renderAvatarToEl(avatarUrl, el){
        el.innerHTML = ''; // Clear existing content
        if(avatarUrl){
          const img = document.createElement('img');
          img.src = avatarUrl;
          img.alt = 'User avatar';
          el.appendChild(img);
        }
      }

      function createMessageElement(messageData, isMe){
        if(!messageData || isUserMuted(messageData.username)) return null;

        const div = document.createElement('div');
        div.className = 'message';
        div.dataset.id = messageData.id;
        if(isMe) div.classList.add('me');

        const bubble = document.createElement('div');
        bubble.className = 'bubble';

        const metaDiv = document.createElement('div');
        metaDiv.className = 'meta';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'name';
        nameSpan.textContent = messageData.username || 'Anon';
        if(messageData.nameColor) nameSpan.style.color = messageData.nameColor;
        const timeSpan = document.createElement('span');
        timeSpan.className = 'time';
        timeSpan.textContent = formatTime(messageData.createdAt);
        metaDiv.append(nameSpan, timeSpan);

        // Message content based on channel type
        if(activeChannel === 'photos' && messageData.imageUrl){
          const photoDiv = document.createElement('div');
          photoDiv.className = 'photoMessage';
          const img = document.createElement('img');
          img.src = messageData.imageUrl;
          img.alt = 'User photo';
          img.onclick = ()=> window.open(messageData.imageUrl, '_blank');
          photoDiv.appendChild(img);
          bubble.append(metaDiv, photoDiv);
        } else if(activeChannel === 'code' && messageData.code){
          const codeDiv = document.createElement('div');
          codeDiv.className = 'code-block';
          
          if(messageData.language){
            const langTag = document.createElement('div');
            langTag.className = 'language-tag';
            langTag.textContent = messageData.language.toUpperCase();
            codeDiv.appendChild(langTag);
          }
          
          const codeText = document.createElement('div');
          codeText.textContent = messageData.code;
          codeDiv.appendChild(codeText); // No need for specific margin-top here if CSS is clean
          
          const copyBtn = document.createElement('button');
          copyBtn.className = 'copy-btn';
          copyBtn.textContent = 'Copy';
          copyBtn.onclick = ()=>{
            navigator.clipboard.writeText(messageData.code).then(()=>{
              copyBtn.textContent = 'Copied!';
              copyBtn.classList.add('copied');
              setTimeout(()=>{ copyBtn.textContent = 'Copy'; copyBtn.classList.remove('copied'); }, 2000);
            }).catch(()=>{
              copyBtn.textContent = 'Failed';
              setTimeout(()=>{ copyBtn.textContent = 'Copy'; }, 2000);
            });
          };
          codeDiv.appendChild(copyBtn);
          
          bubble.append(metaDiv, codeDiv);
        } else {
          // General text message (potentially with reply)
          if(messageData.replyTo && messageData.replyTo.username && messageData.replyTo.message){
            const replyQuote = document.createElement('div');
            replyQuote.className = 'replyQuote';
            const replyText = messageData.replyTo.message.length > 50 ? messageData.replyTo.message.substring(0, 50) + '...' : messageData.replyTo.message;
            replyQuote.textContent = `â†©ï¸ ${messageData.replyTo.username}: ${replyText}`;
            bubble.appendChild(replyQuote);
          }

          const textDiv = document.createElement('div');
          textDiv.className = 'text';
          let msgText = messageData.message || '';
          const mentionRegex = /@(\w{1,8})/g;
          let parts = [];
          let lastIndex = 0;
          let match;
          while((match = mentionRegex.exec(msgText)) !== null){
            if(match.index > lastIndex){
              parts.push(document.createTextNode(msgText.slice(lastIndex, match.index)));
            }
            const mentionSpan = document.createElement('span');
            mentionSpan.className = 'mention';
            mentionSpan.textContent = match[0];
            parts.push(mentionSpan);
            if(match[1].toLowerCase() === username.toLowerCase() && messageData.id && !notifiedSet.has(messageData.id)){
              if('Notification' in window && Notification.permission === 'granted'){
                try{ new Notification('notcord mention', { body: `${messageData.username} mentioned you: ${msgText.slice(0,60)}...` }); }catch(e){}
              }
              notifiedSet.add(messageData.id);
              const arr = Array.from(notifiedSet).slice(-200); // Keep last 200 notifications
              localStorage.setItem(notifiedKey, JSON.stringify(arr));
            }
            lastIndex = match.index + match[0].length;
          }
          if(lastIndex < msgText.length){
            parts.push(document.createTextNode(msgText.slice(lastIndex)));
          }
          for(const p of parts) textDiv.appendChild(p);

          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'actions';
          const replyBtn = document.createElement('button');
          replyBtn.textContent = 'â†©ï¸';
          replyBtn.title = 'Reply';
          replyBtn.onclick = ()=>{
            replyToMessage = { username: messageData.username, message: messageData.message, id: messageData.id };
            messageInput.focus();
            setStatus('Replying to ' + messageData.username);
          };
          actionsDiv.appendChild(replyBtn);

          bubble.append(metaDiv, textDiv, actionsDiv);
        }

        const avatarEl = document.createElement('div');
        avatarEl.className = 'avatar-placeholder';
        renderAvatarToEl(messageData.avatarUrl, avatarEl);

        div.append(avatarEl, bubble);
        return div;
      }

      function renderMessages(msgs){
        messagesEl.innerHTML = '';
        for(const m of msgs){
          const messageElement = createMessageElement(m, m.username === username);
          if (messageElement) {
            messagesEl.appendChild(messageElement);
          }
        }

        // Auto-scroll to bottom only if not manually scrolled up
        if (!firstOpenScrollDone || (messagesEl.scrollHeight - messagesEl.scrollTop <= messagesEl.clientHeight + 100)) { // Add some buffer for manual scroll up
          messagesEl.scrollTop = messagesEl.scrollHeight;
          firstOpenScrollDone = true;
        }
      }

      async function postMessage(text){
        if(!text || !text.trim()) return;
        if(!username){ setStatus('Set username first'); return; }
        if(isUserMuted(username)){ setStatus('You are muted.'); return; }
        if(containsBadWords(text)){
          muteUser(username, 120);
          setStatus('Forbidden word detected. You are muted for 2 minutes.');
          return;
        }
        isSending = true;
        try{
          const payload = { 
            username, 
            message: text, 
            createdAt: new Date().toISOString(), 
            nameColor, 
            avatarUrl: avatarDataUrl || null,
            replyTo: replyToMessage ? { username: replyToMessage.username, message: replyToMessage.message, id: replyToMessage.id } : null
          };
          const res = await fetch(apiBase, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if(!res.ok) throw new Error('post failed');
          replyToMessage = null; // Clear reply state
          messageInput.value = ''; updateCharCountAndState(); // Clear input and update UI
          const map = readTypingMap(); // Clear typing status
          if(map[activeChannel] && map[activeChannel][username]){ delete map[activeChannel][username]; writeTypingMap(map); updateTypingUI(); }
          await fetchMessages(); // Refresh messages
        }catch(e){
          console.error(e);
          setStatus('Failed to send');
        }finally{
          isSending = false;
        }
      }

      async function uploadCode(){
        const code = codeInput.value;
        if(!code || !code.trim()){ setStatus('Enter some code first'); return; }
        if(!username){ setStatus('Set username first'); return; }
        if(isUserMuted(username)){ setStatus('You are muted'); return; }
        isSending = true;
        try{
          const language = languageInput.value.trim() || 'text';
          const payload = { username, code, language, createdAt: new Date().toISOString(), nameColor, avatarUrl: avatarDataUrl || null };
          const res = await fetch(CHANNELS.code, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if(!res.ok) throw new Error('upload failed');
          setStatus('Code uploaded');
          codeInput.value = '';
          languageInput.value = '';
          await fetchMessages();
        }catch(e){
          console.error(e);
          setStatus('Code upload failed');
        }finally{
          isSending = false;
        }
      }

      // --- Event Listeners ---
      // Channel switching via event delegation
      channelsEl.addEventListener('click', async (e)=>{
        const channelDiv = e.target.closest('.channel');
        if(channelDiv){
          const id = channelDiv.dataset.id;
          if(!id || id === activeChannel) return;
          await setActiveChannel(id);
        }
      });

      setNameBtn.addEventListener('click', async ()=>{
        const u = usernameInput.value.trim();
        if(!u){ setStatus('Enter username'); return; }
        if(u.length > 8){ setStatus('Username max 8 chars'); return; }
        if(containsBadWords(u)){ setStatus('Forbidden name'); return; }
        username = u;
        const now = Date.now();
        lastNameChange = now;
        localStorage.setItem('notcord_lastNameChange', String(lastNameChange));
        localStorage.setItem('notcord_username', username);
        usernameBox.classList.add('hidden');
        usernameLocked.classList.remove('hidden');
        usernameDisplay.textContent = username;
        nameMeta.textContent = avatarDataUrl ? 'Avatar set' : 'No avatar';
        renderAvatarToEl(avatarDataUrl, avatarDisplay);
        await upsertLocalPlayer();
        await setLocalPlayerOnlineState(true);
        startHeartbeat();
        await fetchPlayers();
        updateCharCountAndState();
      });

      changeNameBtn.addEventListener('click', ()=>{
        const now = Date.now();
        if(now - lastNameChange < WEEK_MS){
          const hours = Math.ceil((WEEK_MS - (now - lastNameChange))/3600000);
          setStatus(`Name can be changed in ${hours}h`);
          return;
        }
        usernameInput.value = username || '';
        usernameBox.classList.remove('hidden');
        usernameLocked.classList.add('hidden');
      });

      avatarInput.addEventListener('change', async (e)=>{
        const file = avatarInput.files[0];
        if(!file) return;
        const now = Date.now();
        if(now - lastAvatarChange < WEEK_MS){
          const hrs = Math.ceil((WEEK_MS - (now - lastAvatarChange))/3600000);
          setStatus(`Avatar can be changed in ${hrs}h`);
          avatarInput.value = '';
          return;
        }
        try{
          const r = await resizeImageFile(file, 256, 256);
          if(!r.ok) throw new Error('avatar resize failed');
          avatarDataUrl = r.dataUrl;
          localStorage.setItem('notcord_avatar', avatarDataUrl);
          lastAvatarChange = now;
          localStorage.setItem('notcord_lastAvatarChange', String(lastAvatarChange));
          renderAvatarToEl(avatarDataUrl, avatarDisplay);
          nameMeta.textContent = 'Avatar set';
          setStatus('Avatar updated');
          if(localPlayerId) await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { avatarUrl: avatarDataUrl, name: username, lastSeen: new Date().toISOString(), nameColor });
          await fetchPlayers();
        }catch(err){ console.error(err); setStatus('Avatar upload failed'); }
        finally{ avatarInput.value = ''; }
      });

      changeAvatarBtn.addEventListener('click', ()=> avatarInput.click());

      sendBtn.addEventListener('click', ()=> postMessage(messageInput.value));

      messageInput.addEventListener('input', ()=>{
        updateCharCountAndState();
        if(username){
          const map = readTypingMap(); map[activeChannel] = map[activeChannel] || {}; map[activeChannel][username] = Date.now(); writeTypingMap(map); updateTypingUI();
        }
      });

      messageInput.addEventListener('keydown', (e)=>{ 
        if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); if(!sendBtn.disabled) sendBtn.click(); }
        if(e.key === 'Escape'){ if(replyToMessage){ replyToMessage = null; setStatus('Reply cancelled'); } messageInput.blur(); }
      });

      photoInput.addEventListener('change', ()=> uploadPhotoBtn.disabled = !photoInput.files.length );
      uploadPhotoBtn.addEventListener('click', ()=> { if(photoInput.files.length) uploadPhoto(photoInput.files[0]); });
      
      uploadCodeBtn.addEventListener('click', uploadCode);

      // Consolidated theme settings
      const themeControls = [
        { input: nameColorInput, key: 'nameColor', default: '#F5F5F5' },
        { input: themeColor1Input, key: 'theme1', default: '#1B2B3A' },
        { input: themeColor2Input, key: 'theme2', default: '#0F1A25' },
        { input: themeColor3Input, key: 'theme3', default: '#2B3A4A' },
        { input: accentColorInput, key: 'accent', default: '#3F72AF' }
      ];

      themeControls.forEach(({ input, key, default: defaultValue }) => {
        input.addEventListener('input', async (e) => {
          window[key] = e.target.value;
          localStorage.setItem(`notcord_${key}`, window[key]);
          applyTheme();
          if (key === 'nameColor' && localPlayerId) {
            await safeFetch(`${PLAYERS_API}/${localPlayerId}`, 'PUT', { name: username, lastSeen: new Date().toISOString(), nameColor, avatarUrl: avatarDataUrl });
            fetchPlayers().catch(()=>{});
          }
        });
      });

      resetNameColorBtn.addEventListener('click', ()=> { nameColor='#F5F5F5'; nameColorInput.value = nameColor; localStorage.setItem('notcord_nameColor', nameColor); });
      resetTheme1Btn.addEventListener('click', ()=> { themeColor1='#1B2B3A'; themeColor1Input.value = themeColor1; localStorage.setItem('notcord_theme1', themeColor1); applyTheme(); });
      resetTheme2Btn.addEventListener('click', ()=> { themeColor2='#0F1A25'; themeColor2Input.value = themeColor2; localStorage.setItem('notcord_theme2', themeColor2); applyTheme(); });
      resetTheme3Btn.addEventListener('click', ()=> { themeColor3='#2B3A4A'; themeColor3Input.value = themeColor3; localStorage.setItem('notcord_theme3', themeColor3); applyTheme(); });
      resetAccentBtn.addEventListener('click', ()=> { accentColor='#3F72AF'; accentColorInput.value = accentColor; localStorage.setItem('notcord_accent', accentColor); applyTheme(); });

      // Switch channel
      async function setActiveChannel(id){
        firstOpenScrollDone = false; // Reset scroll flag for new channel
        activeChannel = id; apiBase = CHANNELS[id] || null; localStorage.setItem('notcord_channel', id);
        Array.from(channelsEl.children).forEach(ch => ch.classList.toggle('active', ch.dataset.id === id));
        channelTitleEl.textContent = '# ' + id;
        updateInputArea();
        if(pollingMessagesInterval) clearInterval(pollingMessagesInterval);
        await fetchMessages();
        // Polling interval adjusted for different channels
        if(id === 'general') {
            pollingMessagesInterval = setInterval(fetchMessages, 2000);
        } else if (id === 'photos' || id === 'code') {
            pollingMessagesInterval = setInterval(fetchMessages, 3000); // Less frequent for photo/code
        }
      }

      function updateCharCountAndState(){
        let val = messageInput.value || '';
        if(val.length > MAX_CHARS_MESSAGE) messageInput.value = val.slice(0, MAX_CHARS_MESSAGE);
        charCountEl.textContent = `${(messageInput.value||'').length} / ${MAX_CHARS_MESSAGE}`;
        const canSend = username && (messageInput.value||'').trim().length > 0 && activeChannel !== 'photos' && activeChannel !== 'code' && !isSending && !isUserMuted(username);
        sendBtn.disabled = !canSend;
      }

      function updateInputArea(){
        // Hide all, then show the relevant one
        inputWrapper.classList.add('hidden');
        photoUploadWrapper.classList.add('hidden');
        codeUploadWrapper.classList.add('hidden');

        if(activeChannel === 'photos'){
          photoUploadWrapper.classList.remove('hidden');
          uploadPhotoBtn.disabled = !photoInput.files.length;
        } else if (activeChannel === 'code') {
          codeUploadWrapper.classList.remove('hidden');
        } else {
          inputWrapper.classList.remove('hidden');
        }
      }

      // Image resizing function
      function resizeImageFile(file, maxWidth=1200, maxHeight=1200){
        return new Promise((resolve, reject)=>{
          // For GIFs, just return the data URL directly without resizing
          if(!file.type || file.type === 'image/gif'){
            const reader = new FileReader();
            reader.onload = (e)=> resolve({ ok:true, dataUrl: e.target.result });
            reader.onerror = reject;
            reader.readAsDataURL(file);
            return;
          }
          const reader = new FileReader();
          reader.onload = (e)=>{
            const img = new Image();
            img.onload = ()=>{
              let w = img.width, h = img.height;
              // Dynamically adjust quality/size based on original file size
              const sizeKB = file.size / 1024;
              let factor = 1;
              if(sizeKB > 1500) factor = 0.55;
              else if(sizeKB > 900) factor = 0.75;
              else if(sizeKB > 400) factor = 0.9;
              const targetW = Math.round(maxWidth * factor);
              const targetH = Math.round(maxHeight * factor);
              const ratio = Math.min(targetW / w, targetH / h, 1);
              w = Math.round(w * ratio); h = Math.round(h * ratio);
              const canvas = document.createElement('canvas');
              canvas.width = w; canvas.height = h;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img,0,0,w,h);
              const quality = (sizeKB > 1200) ? 0.75 : 0.85;
              const dataUrl = canvas.toDataURL('image/jpeg', quality);
              resolve({ ok:true, dataUrl });
            };
            img.onerror = (err)=> reject(err);
            img.src = e.target.result;
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      // Upload photo
      async function uploadPhoto(file){
        if(!file) return;
        if(!username){ setStatus('Set username first'); return; }
        if(isUserMuted(username)){ setStatus('You are muted and cannot upload'); return; }
        if(containsBadWords(file.name)){ muteUser(username, 120); setStatus('Forbidden file name. You are muted for 2 minutes.'); return; }
        isSending = true; uploadPhotoBtn.disabled = true;
        try{
          let r = await resizeImageFile(file, 1200, 1200);
          if(!r.ok) throw new Error('Resize failed');
          let dataUrl = r.dataUrl;
          // Further reduce size if still too large after first resize (unless it's a GIF)
          const approxSize = Math.round((dataUrl.length - dataUrl.indexOf(',') - 1) * 3/4); // Base64 approx size calc
          if(approxSize > 1500*1024 && file.type !== 'image/gif'){
            const r2 = await resizeImageFile(file, 800, 800);
            if(r2.ok) dataUrl = r2.dataUrl;
          }
          const payload = { username, createdAt: new Date().toISOString(), nameColor, imageUrl: dataUrl, message: '' , avatarUrl: avatarDataUrl || null};
          const res = await fetch(CHANNELS.photos, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          if(!res.ok) throw new Error('Upload failed: '+res.status);
          setStatus('Photo uploaded');
          photoInput.value = ''; // Clear file input
          await fetchMessages();
        }catch(e){
          console.error(e);
          setStatus('Photo upload failed');
        }finally{
          isSending = false; uploadPhotoBtn.disabled = false;
        }
      }

      // cleanup typing
      function cleanupTypingMap(){
        const map = readTypingMap(); const now = Date.now(); let changed = false;
        for(const ch of Object.keys(map)){ for(const u of Object.keys(map[ch])){ if(now - map[ch][u] > TYPING_EXPIRE_MS){ delete map[ch][u]; changed = true; } } if(Object.keys(map[ch]).length===0) delete map[ch]; }
        if(changed) writeTypingMap(map);
        updateTypingUI();
      }

      // Initial load
      async function init(){
        applyTheme(); initializeAppearanceInputs();
        
        if(avatarDataUrl) renderAvatarToEl(avatarDataUrl, avatarDisplay);
        
        if(username){ 
          usernameBox.classList.add('hidden'); 
          usernameLocked.classList.remove('hidden'); 
          usernameDisplay.textContent = username; 
          nameMeta.textContent = avatarDataUrl? 'Avatar set' : 'No avatar'; 
          await upsertLocalPlayer(); 
          await setLocalPlayerOnlineState(true); 
          startHeartbeat(); 
        } else { 
          usernameBox.classList.remove('hidden'); 
          usernameLocked.classList.add('hidden'); 
        }

        await fetchPublicPinned();
        startPinRotation(7000);
        await setActiveChannel(activeChannel);
        await fetchPlayers();
        
        if(pollingPlayersInterval) clearInterval(pollingPlayersInterval);
        pollingPlayersInterval = setInterval(fetchPlayers, 5000);
        
        setInterval(cleanupTypingMap, 2000);
        setInterval(fetchPublicPinned, 15000);
        initPresets();
      }
      init();

      // visibility handling
      document.addEventListener('visibilitychange', async ()=>{
        if(!username) return;
        if(document.hidden){
          try{
            if(localPlayerId && navigator.sendBeacon){
              const url = `${PLAYERS_API}/${localPlayerId}`;
              const payload = JSON.stringify({ lastSeen: new Date().toISOString(), online:false, name: username, nameColor, avatarUrl: avatarDataUrl });
              const blob = new Blob([payload], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
            } else {
              await setLocalPlayerOnlineState(false);
            }
          }catch(e){}
          stopHeartbeat();
        } else {
          await upsertLocalPlayer();
          startHeartbeat();
        }
      });

      window.addEventListener('beforeunload', (e)=>{
        try{
          if(localPlayerId){
            const url = `${PLAYERS_API}/${localPlayerId}`;
            const payload = JSON.stringify({ lastSeen: new Date().toISOString(), online:false, name: username, nameColor, avatarUrl: avatarDataUrl });
            if(navigator.sendBeacon){
              const blob = new Blob([payload], { type: 'application/json' });
              navigator.sendBeacon(url, blob);
            } else {
              // Fallback for browsers not supporting sendBeacon (unlikely for modern browsers)
              // Note: This fetch might be cancelled by the browser, but it's the best effort without sendBeacon.
              fetch(url, { method:'PUT', headers:{'Content-Type':'application/json'}, body: payload, keepalive: true }).catch(()=>{});
            }
          }
        }catch(e){
          console.error("Error sending beacon/fetch on unload:", e);
        }
        // No need to prevent default for beforeunload unless you want to prompt the user
      });

      // Expose debug
      window._notcord = { fetchMessages, fetchPlayers, fetchPublicPinned, publicPinnedList, startPinRotation, getPresets, loadPreset, saveCurrentToPreset, resetPreset };

    })();
  </script>
</body>
</html>
